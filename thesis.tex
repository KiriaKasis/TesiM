\documentclass[11pt,a5paper,draft,oneside]{amsbook}
\usepackage[greek,italian,english]{babel}
\usepackage{amsmath, amsthm, amsopn}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{lmodern}
%\usepackage{fourier}
%\usepackage[garamonf]{mathdesign}
%\usepackage{fontspec}  

\usepackage[T1]{fontenc}
%\usepackage[left=0.5cm,
%			right=8cm,top=0.5cm,
%			bottom=0.5cm]{geometry}
%\usepackage{mathrsfs}
%\usepackage{bussproofs}
%\usepackage{prftree}
\usepackage{ebproof}
%\usepackage{proof}

\author{Alberto Fiori}
\title{Realizzabilità e altre cose interessanti}

\theoremstyle{plain}% default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}
\newtheorem*{KL}{Klein’s Lemma}

\theoremstyle{definition}
\newtheorem{dede}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

\newcommand{\Va}{\mathcal{V}}
\newcommand{\Ve}{\mathcal{E}}
\newcommand{\cp}[1][\cdot,\cdot]{<#1>}
\newcommand{\ctr}{\triangleright}
\newcommand{\sbs}[3]{#1\left\lbrace #2 / #3 \right\rbrace}

\newcommand{\uplaOp}[3]{#1_{1}#3\dots#3#1_{#2}}
\newcommand{\upla}[2]{\uplaOp{#1}{#2}{,}}
\newcommand{\xnContext}[3]
	{#2_1   \in #1_1 
						, \dots, 
	#2_{#3} \in #1_{#3}{(\uplaOp{#2}{#3-1}{,})}}
	
	
\newcommand{\femph}{\textbf}
\begin{document}
\maketitle
\begin{abstract}
	As I understand it the speciality of a 
	realizzability 	interpretation is in 
	being looser, for example in this theory
	the term $natrec(x, 0, 0)$, where x is a free variable, belongs to every type despite not even being well formed in a type theory context. 
\end{abstract}

\section{Copycatting: Let's get vaguely serious}
	\subsection{Starting definitions}
		We are going to give a different interpretation 
		of the same language used in the Minimalist 
		Foundation. Una delle differenza sarà che definiremo
		un'untyped relazione di riducibilità invece 
		del giudizio di uguanza tipata; then using the distinction in \femph{canonical} and \femph{non-canonical} expression we will define the set of \femph{normal} expressions (le espressioni normali in mtt sono normali anche qui)
		Let's give a simple grammar for our language~(in this interpretation we don't actually diffenrentiate between types and elements): let $\Va$ be an infinite set of variables (generally denoted with $x,y,z,w$ and with \footnote{pensando di nuovo a come trattare il concetto delle \emph{astrazioni} in \textsl{proglöf} credo che per ora la cosa migliore sia dimenticarsene e non usarle}		
\begin{dede}
	The set of expression $\Ve$ will be inductively genererated from the set of variables $\Va$ as closed under the following construct:
	\begin{gather}
	 \lambda x.e \\
	 apply(e_1,e_2) \\
	 0 \\ 
	 succ(e) \\ 
	 natrec(e_1,e_2,e_3) \\ 
	 \cp[e_1,\,e_2] \\
	 El_\Sigma(e_1, e_2) \\
	 N 		\\
	 \Sigma(e_1,e_2)\\
	 \Pi(e_1,e_2)
	\end{gather}
	where $x$ is a variable and each $e_i$ is a previously constructed expression.
	\end{dede}
	\begin{dede}
		An expression is said to be \femph{canonical} if it is in the form $\lambda x.e$, 0, $succ(e)$, $\cp[e_1,e_2]$ 
	\end{dede}
	
	\begin{dede}
		the \femph{contraction} relation (\triangleright)
		is defined by:
		\begin{align}
		natrec(0, b, c) & \ctr & b \\
		apply(\lambda x.e, d) & \ctr & \sbs{b}{a}{c}\\
		el
		\end{align}			
	\end{dede}
	
	\begin{dede}
	Here we give the definition of $\psi$ and $\Psi$ as inference rules:
	\begin{gather}
	\begin{prooftree}
	\Infer{0}{\Psi(N)}
	\end{prooftree}	\\
	%	
	\begin{prooftree}
	\Hypo{\Psi(A)}
	\Hypo{\Psi(B(a)) \left[\psi(A,h,a)\right]}
	\Infer2{\Sigma(A,B)}		
	\end{prooftree}\\
	%
	%
	\begin{prooftree}
	\Hypo{\Psi(A)}
	\Hypo{\Psi(B(a)) \left[\psi(A,h,a)\right]}
	\Infer2{\Pi(A,B)}		
	\end{prooftree}\\
	%
	\begin{prooftree}
	%
	\Hypo{\mathcal{F}(A)}
	\Infer1{\Psi(A)}
	\end{prooftree}
	%
	\begin{prooftree}
	\Hypo{A\rightarrow B}
	\Hypo{\Psi(B)}
	\Infer2{\Psi(A)}
	\end{prooftree}
	\end{gather}
	
	
	\begin{gather}
	%
	\begin{prooftree}
	\Hypo{a \rightarrow b}
	\Hypo{\mathcal{N}(b) }
	\Infer2{\psi(N,a)}
	\end{prooftree}	
		%
	\\
	\begin{prooftree}
		\Hypo{c_{1b} \colon \Psi(\Pi(A,B))}
		\Hypo{\psi(B(a), apply(b, a))[\psi(A,a)]}
		\Infer{2}{\psi(\Pi(A,B),c_?,b)}
	\end{prooftree}\\		
	%
	\begin{prooftree}
	\Hypo{c_{1c} \colon \Psi(A)}
	\Hypo{a \rightarrow b}
	\Hypo{\mathcal{F}(b)}
	\Infer3{\psi(A,a)}
	\end{prooftree}	\\		
	%
	\begin{prooftree}
	\Hypo{c_{1d}(A,B,h) \colon \Psi(A)}
	\Hypo{\psi(B,a)}
	\Infer2{\psi(A,a)}
	\end{prooftree}	
	\end{gather}
	
	\begin{gather}
	%
	\begin{prooftree}
	\Hypo{\phantom{\Psi(A)}}
	\Infer1{\Phi(U)}
	\end{prooftree}
	%
	\begin{prooftree}
	\Hypo{\Psi(A)}
	\Infer1{\phi(U,A)}
	\end{prooftree}	
	\end{gather}	
	
	\end{dede}
	
	The normalization theorem will be proved in two steps. In the first step we will prove basic properties of this \emph{Realizzability Interpretation} (such as being normalizing and having other computational properties). In the second step we will give a proof of compatibility between the Minimalist Foundation and the 
	
 	
	\begin{lem}[qwe]
	
	\end{lem}
\chapter{Expression Language}
	The following is based on the ideas that I first read in the book "programming in Martin Löf type thery" 
	\footnote{\label{qwe13}Non sono più convinto di questa cosa; nel libro si parla escusivamente di \emph{MLTT} dove c'è un enorme rigidità nelle costruzioni ammesse, al contrario quando siamo in realizzabilità abbiamo decisamente una maggior libertà: potremmo per esempio scrivere l'espressione $\text{apply}(0,0)$ semplicemente questa non farebbe parte di alcun tipo.
	rimarrebbe ora da decidere come trattare il concetto di arietà funzionale, la Coquand definisce il costruttore di funzione come $\lambda x . e$ dando nomi espliciti alle variabili e richiamandosi all'operatore di sostituzione $B\{a/x\}$ per rappresentare i ``conti'' seguendo questa struttura, la consueta sintassi di funzione diventa obsoleta, il lambda calcolo funzionale (i.e.\ $(x).f$ o $\left\langle x\right\rangle.f$) diventa di fatto non strettamente necessario negli usi che servono nell'articolo. \\
	Questo mi porta a propormi di non accanirmi sulle a
	rietà di non preoccuparsi troppo del $\lambda x.e$ dei $\Pi$-tipi (a cui n
	on sono troppo abituato: $\lambda x.e 
	= \lambda ((x).e)$) 
	}. 
	Basically every expression we write in a mathematical expression has an arity (0,$\alpha\rightarrow\beta$, $\alpha_1\otimes\alpha_2\ldots\otimes\alpha_n$) which work similarly to how types in simply typed lambda calculus work. 
	This simply is a way to ensure that expression are well-formed (even if it doesn't ensure that they are reasonable); we chose to add the $\otimes\ldots\otimes$ constructor to freely chose when to \emph{curry} and \emph{uncurry} function application; we could have added more, but there seem to be no advantage in doing so.
	
	The rule for arity are the expected ones:
	%TODO non so come fare le deduzioni naturali
	
	\section{Everithhung has an Arity} 
		123123123123
	\section{The previous section was a bad idea}
		As already pointed out in the footnote~\ref{qwe13} on page \pageref{qwe13} it was not a good idea to start from the wellformedness of formulas as to prove the normalization theorem we need just the concepts of \femph{canonical} 
		and \femph{non-canonical} and the \femph{tree-like} structure of expressions to define the reducibility relation ricursively.
		
		In the whole article, I think, nothing else was used.
		
\end{document}
