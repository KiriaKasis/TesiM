\documentclass[11pt,a5paper,draft,oneside]{amsbook}
\usepackage[greek,italian,english]{babel}
\usepackage{amsmath, amsthm, amsopn}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bm}
%\usepackage{lmodern}
\usepackage{fourier}
%\usepackage[charter]{mathdesign}
%\usepackage{fontspec}  
%\setmainfont{EB Garamond}[
%  Contextuals={Alternate},
%  Numbers=OldStyle,
%]

\usepackage[T1]{fontenc}
\usepackage[left=0.5cm,
			right=7cm,top=0.5cm,
			bottom=0.5cm]{geometry}
%\usepackage{mathrsfs}
%\usepackage{bussproofs}
%\usepackage{prftree}
\usepackage{ebproof}
\usepackage{proof}

\author{Alberto Fiori}
\title{Realizzabilità e altre cose interessanti}

\newcommand{\uplaOp}[3]{(#1_{1}#3\dots#3#1_{#2})}
\newcommand{\xnContext}[3]
	{#2_1   \in #1_1 
						, \dots, 
	#2_{#3} \in #1_{#3}{\uplaOp{#2}{#3-1}{,}}}
	
	
\newcommand{\femph}{\textbf}
\begin{document}
\maketitle
\begin{abstract}
	As I understand it the speciality of a 
	realizzability 	interpretation is in 
	being looser, for example in this theory
	the term $natrec(x, 0, 0)$, where x is a free variable, belongs to every type despite not even being well formed in a type theory context. 
\end{abstract}

\section{Copycatting: Let's get vaguely serious}
	\subsection{Starting definitions}
		We are going to give a different interpretation 
		of the same language used in the Minimalist 
		Foundation. Una delle differenza sarà che definiremo
		un'untyped relazione di riducibilità invece 
		del giudizio di uguanza tipata; then using the distinction in \femph{canonical} and \femph{non-canonical} expression we will define the set of \femph{normal} expressions (le espressioni normali in mtt sono normali anche qui)
		Let's give a simple grammar for our language~(in this interpretation we don't actually diffenrentiate between types and elements)
		\
		  

\chapter{Expression Language}
	The following is based on the ideas that I first read in the book "programming in Martin Löf type thery" 
	\footnote{\label{qwe13}Non sono più convinto di questa cosa; nel libro si parla escusivamente di \emph{MLTT} dove c'è un enorme rigidità nelle costruzioni ammesse, al contrario quando siamo in realizzabilità abbiamo decisamente una maggior libertà: potremmo per esempio scrivere l'espressione $\text{apply}(0,0)$ semplicemente questa non farebbe parte di alcun tipo.
	rimarrebbe ora da decidere come trattare il concetto di arietà funzionale, la Coquand definisce il costruttore di funzione come $\lambda x . e$ dando nomi espliciti alle variabili e richiamandosi all'operatore di sostituzione $B\{a/x\}$ per rappresentare i ``conti'' seguendo questa struttura, la consueta sintassi di funzione diventa obsoleta, il lambda calcolo funzionale (i.e.\ $(x).f$ o $\left\langle x\right\rangle.f$) diventa di fatto non strettamente necessario negli usi che servono nell'articolo. \\
	Questo mi porta a propormi di non accanirmi sulle a
	rietà di non preoccuparsi troppo del $\lambda x.e$ dei $\Pi$-tipi (a cui n
	on sono troppo abituato: $\lambda x.e 
	= \lambda ((x).e)$) 
	}. 
	Basically every expression we write in a mathematical expression has an arity (0,$\alpha\rightarrow\beta$, $\alpha_1\otimes\alpha_2\ldots\otimes\alpha_n$) which work similarly to how types in simply typed lambda calculus work. 
	This simply is a way to ensure that expression are well-formed (even if it doesn't ensure that they are reasonable); we chose to add the $\otimes\ldots\otimes$ constructor to freely chose when to \emph{curry} and \emph{uncurry} function application; we could have added more, but there seem to be no advantage in doing so.
	
	The rule for arity are the expected ones:
	%TODO non so come fare le deduzioni naturali
	
	\section{Everithhung has an Arity} 
		123123123123
	\section{The previous section was a bad idea}
		As already pointed out in the footnote~\ref{qwe13} on page \pageref{qwe13} it was not a good idea to start from the wellformedness of formulas as to prove the normalization theorem we need just the concepts of \femph{canonical} 
		and \femph{non-canonical} and the \femph{tree-like} structure of expressions to define the reducibility relation ricursively.
		
		In the whole article, I think, nothing else was used.
\chapter{Test stuff}
	\begin{eqnarray}
		\infer{B}{A & (A \rightarrow B)}	\\
		\infer{B}{A & (A \rightarrow B)}	\\
		\infer={B \land A}{A \land B)}		\\
		\infer[^{(2)}]
     {\neg(\phi \land \psi)}
     {\infer[^{(1)}]
        {\bot}
        {(\neg\phi \lor \neg\psi) & \bot & \bot}
     }
     \\
     \infer[^{(2)}]
     {\neg(\phi \land \psi)}
     {\infer[^{(1)}]
        {\bot}
        {(\neg\phi \lor \neg\psi) & 
        \infer
            {\bot}
            {\phi & 
            \infer[^{(1)}]
            {\neg\phi}{}
            } 
        & \bot}
     }\\     
	\end{eqnarray}
$$
\infer[(\to I)]
     {(A \to B)}
     {
     \infer*{B}{[A]}
     }
\qquad
\infer[(\to E)]
     {B}
     {(A \to B) & A}
$$



The rule 
$\vcenter
{
\infer
    {(A \to B)}
    {
    \infer*{B}{[A] A & A & A}
    }
}$
is known as $\to$-intro
\newpage
\[
\begin{prooftree}
\Hypo{ \vdash A }
\Hypo{ \vdash B } \Infer1{ \vdash B, C }
\Infer2{ \vdash A\wedge B, C }
\end{prooftree}
%
\quad \rightsquigarrow \quad
\begin{prooftree}
\Hypo{ \vdash A } \Hypo{ \vdash B }
\Infer2{ \vdash A\wedge B }
\Infer1{ \vdash A\wedge B, C }
\end{prooftree}
\]

\end{document}