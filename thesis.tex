\documentclass[12pt,draft,oneside]{amsbook}
\input{thesis_pre}
\author{Alberto Fiori}
\title{Realizzabilità e altre cose interessanti}


\begin{document}
\maketitle
\chapter{The Interpretation}
	As I understand it the speciality of a 
	realizzability 	interpretation is in 
	being looser, for example in this theory
	the term $natrec(x, 0, 0)$, where x is a 
	free variable, belongs to every type despite 
	not even being well formed in a type theory context \footnote{Ho risolto il  problema!! tutte le \emph{astrazioni-funzioni} sono delle $\lambda$ nella realizzabilità tanto solanto i termini di arietà 0 possono essere tipati in \femph{MTT}}.



\section{Copycatting: Let's get vaguely serious}
	\subsection{Starting definitions}
		We are going to give a different interpretation 
		of the same language used in the Minimalist 
		Foundation. Una delle differenza sarà che definiremo
		un'untyped relazione di riducibilità invece 
		del giudizio di uguanza tipata; then using the distinction in \femph{canonical} and \femph{non-canonical} expression we will define the set of \femph{normal} expressions (le espressioni normali in mtt sono normali anche qui)
		Let's give a simple grammar for our language~(in this interpretation we don't actually diffenrentiate between types and elements): let $\Va$ be an infinite set of variables (generally denoted with $x,y,z,w$ and with \footnote{pensando di nuovo a come trattare il concetto delle \emph{astrazioni} in \textsl{proglöf} credo che per ora la cosa migliore sia dimenticarsene e non usarle}		
\begin{dede}
	The set of expression $\Ve$ will be inductively genererated from the set of variables $\Va$ as closed under the following construct:
	\begin{gather}
	 \lambda x.e \\
	 apply(e_1,e_2) \\
	 0 \\ 
	 succ(e) \\ 
	 natrec(e_1,e_2,e_3) \\ 
	 \cp[e_1,\,e_2] \\
	 El_\Sigma(e_1, e_2) \\
	 N 		\\
	 \Sigma(e_1,e_2)\\
	 \Pi(e_1,e_2)
	\end{gather}
	where $x$ is a variable and each $e_i$ is a previously constructed expression.
	\end{dede}
	\begin{dede}
		An expression is said to be \femph{canonical} if it is in the form $\lambda x.e$, 0, $succ(e)$, $\cp[e_1,e_2]$ 
	\end{dede}
	
	\begin{dede}
		the \femph{contraction} relation ($\ctr$)
		is defined by:
		\begin{equation}
		\begin{split}
		natrec(0, b, c) & \ctr  b \\
		natrec(succ(a), b, c) & \ctr  apply(apply(c,  a), natrec(a, b, c)) \\
		apply(\lambda x.e, d) & \ctr  \sbs{b}{a}{c}\\
		p_0(\cp[a,b]) & \ctr a\\
		p_1(\cp[a,b]) & \ctr b		
		\end{split}
		\end{equation}	
	\end{dede}
	
	\begin{dede}
	Here we give the definition of $\psi$ and $\Psi$ as inference rules:
	\begin{gather*}
	\begin{prooftree}
	\Infer{0}[${}_\RN$]{\Psi(N)}
	\end{prooftree}	\label{def:RN}\\
	%	
	\begin{prooftree}
	\Hypo{\Psi(A)}
	\Hypo{\Psi(B(a)) \left[\psi(A,h,a)\right]}
	\Infer2[${}_\RS$]{\Sigma(A,B)}		
	\end{prooftree}\\
	%
	%
	\begin{prooftree}
	\Hypo{\Psi(A)}
	\Hypo{\Psi(B(a)) \left[\psi(A,h,a)\right]}
	\Infer2[${}_\RP$]{\Pi(A,B)}		
	\end{prooftree}\\
	%
	\begin{prooftree}
	%
	\Hypo{\mathcal{F}(A)}
	\Infer1[${}_\RF$]{\Psi(A)}
	\end{prooftree}
	%
	\begin{prooftree}
	\Hypo{A\rightarrow B}
	\Hypo{\Psi(B)}
	\Infer2[${}_\RAr$]{\Psi(A)}
	\end{prooftree}
	\end{gather*}
	
	
	\begin{gather}
	%
	\begin{prooftree}
	\Hypo{a \rightarrow b}
	\Hypo{\mathcal{N}(b) }
	\Infer2{\psi(N,a)}
	\end{prooftree}	
		%
	\\
	\begin{prooftree}
		\Hypo{c_{1b} \colon \Psi(\Pi(A,B))}
		\Hypo{\psi(B(a), apply(b, a))[\psi(A,a)]}
		\Infer{2}{\psi(\Pi(A,B),c_?,b)}
	\end{prooftree}\\		
		%
	\begin{prooftree}
	\Hypo{c_{1c} \colon \Psi(A)}
	\Hypo{a \rightarrow b}
	\Hypo{\mathcal{F}(b)}
	\Infer3{\psi(A,a)}
	\end{prooftree}	\\		
	%
	\begin{prooftree}
	\Hypo{c_{1d}(A,B,h) \colon \Psi(A)}
	\Hypo{\psi(B,a)}
	\Infer2{\psi(A,a)}
	\end{prooftree}	
	\end{gather}
	
	\begin{gather}
	%
	\begin{prooftree}
	\Hypo{\phantom{\Psi(A)}}
	\Infer1{\Phi(U)}
	\end{prooftree}
	%
	\begin{prooftree}
	\Hypo{\Psi(A)}
	\Infer1{\phi(U,A)}
	\end{prooftree}	
	\end{gather}	
	
	\end{dede}
	
	The normalization theorem will be proved in two steps. In the first step we will prove basic properties of this \emph{Realizzability Interpretation} (such as being normalizing and having other computational properties). In the second step we will give a proof of compatibility between the Minimalist Foundation and the 
	
 	
\chapter{Expression Language}
	The following is based on the ideas that I first read in the book "programming in Martin Löf type thery" 
	\footnote{\label{qwe13}Non sono più convinto di questa cosa; nel libro si parla escusivamente di \emph{MLTT} dove c'è un enorme rigidità nelle costruzioni ammesse, al contrario quando siamo in realizzabilità abbiamo decisamente una maggior libertà: potremmo per esempio scrivere l'espressione $\text{apply}(0,0)$ semplicemente questa non farebbe parte di alcun tipo.
	rimarrebbe ora da decidere come trattare il concetto di arietà funzionale, la Coquand definisce il costruttore di funzione come $\lambda x . e$ dando nomi espliciti alle variabili e richiamandosi all'operatore di sostituzione $B\{a/x\}$ per rappresentare i ``conti'' seguendo questa struttura, la consueta sintassi di funzione diventa obsoleta, il lambda calcolo funzionale (i.e.\ $(x).f$ o $\left\langle x\right\rangle.f$) diventa di fatto non strettamente necessario negli usi che servono nell'articolo. \\
	Questo mi porta a propormi di non accanirmi sulle a
	rietà di non preoccuparsi troppo del $\lambda x.e$ dei $\Pi$-tipi (a cui n
	on sono troppo abituato: $\lambda x.e 
	= \lambda ((x).e)$) 
	}. 
	Basically every expression we write in a mathematical expression has an arity (0,$\alpha\rightarrow\beta$, $\alpha_1\otimes\alpha_2\ldots\otimes\alpha_n$) which work similarly to how types in simply typed lambda calculus work. 
	This simply is a way to ensure that expression are well-formed (even if it doesn't ensure that they are reasonable); we chose to add the $\otimes\ldots\otimes$ constructor to freely chose when to \emph{curry} and \emph{uncurry} function application; we could have added more, but there seem to be no advantage in doing so.
	
	The rule for arity are the expected ones:
	
	\section{Everithhung has an Arity} 
		123123123123
	\section{The previous section was a bad idea}
		As already pointed out in the footnote~\ref{qwe13} on page \pageref{qwe13} it was not a good idea to start from the wellformedness of formulas as to prove the normalization theorem we need just the concepts of \femph{canonical} 
		and \femph{non-canonical} and the \femph{tree-like} structure of expressions to define the reducibility relation ricursively.
		
		In the whole article, I think, nothing else was used.
		\newpage
\section{Properties of the RI}
	\begin{lem}\label{lem:psi}
	If $\Psi(A)$ holds the followings are true:
	\begin{enumerate}
		\item If $a \in \mathcal{F}$ then $\psi(A,c_{(1)_\mathcal{F}},a)$ is derivable.
		\item If $\ps{A}{a}$ and \(a = b\) we have also  $\ps{A}{b}$
		\item If  $\ps{A}{a}$ then $a$ is normalizzable
		\item If $A=B$ then $\Psi(B)$
		\item If $A=B$ and $\Psi(B)$ then $\ps{A}{\cdot} \exteq \ps{B}{\cdot}$
		\item If $A$ is normalizzable
		\item If $A=B$ and $a=b$ then $\ps{A}{a}$ implies $\ps{B}{b}$
	\end{enumerate}
	\end{lem}
	\begin{lem}
	The lemma above is still true if we replace all $\Psi$ with $\Phi$ and all $\psi$ with $\phi$.
	Moreover if $\Psi(A)$ holds then also $\Phi(A)$ holds and we have $\psi(A) \exteq \phi(A)$
	\end{lem}
	The proofs of these two lemmas will be given by induction on the length of the derivation of $\Psi(A)$.
	
	\begin{proof}[Proof \ref{lem:psi}]
	\end{proof}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
\end{document}
