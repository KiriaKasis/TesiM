
\chapter{Expression Language}
	The following is based on the ideas that I first read in the book "programming in Martin Löf type thery" 
	\footnote{\label{qwe13}Non sono più convinto di questa cosa; nel libro si parla escusivamente di \emph{MLTT} dove c'è un enorme rigidità nelle costruzioni ammesse, al contrario quando siamo in realizzabilità abbiamo decisamente una maggior libertà: potremmo per esempio scrivere l'espressione $\text{apply}(0,0)$ semplicemente questa non farebbe parte di alcun tipo.
	rimarrebbe ora da decidere come trattare il concetto di arietà funzionale, la Coquand definisce il costruttore di funzione come $\lambda x . e$ dando nomi espliciti alle variabili e richiamandosi all'operatore di sostituzione $B\{a/x\}$ per rappresentare i ``conti'' seguendo questa struttura, la consueta sintassi di funzione diventa obsoleta, il lambda calcolo funzionale (i.e.\ $(x).f$ o $\left\langle x\right\rangle.f$) diventa di fatto non strettamente necessario negli usi che servono nell'articolo. \\
	Questo mi porta a propormi di non accanirmi sulle a
	rietà di non preoccuparsi troppo del $\lambda x.e$ dei $\Pi$-tipi (a cui n
	on sono troppo abituato: $\lambda x.e 
	= \lambda ((x).e)$) 
	}. 
	Basically every expression we write in a mathematical expression has an arity (0,$\alpha\rightarrow\beta$, $\alpha_1\otimes\alpha_2\ldots\otimes\alpha_n$) which work similarly to how types in simply typed lambda calculus work. 
	This simply is a way to ensure that expression are well-formed (even if it doesn't ensure that they are reasonable); we chose to add the $\otimes\ldots\otimes$ constructor to freely chose when to \emph{curry} and \emph{uncurry} function application; we could have added more, but there seem to be no advantage in doing so.
	
	The rule for arity are the expected ones:
	
	\section{Everithhung has an Arity} 
		123123123123
	\section{The previous section was a bad idea}
		As already pointed out in the footnote~\ref{qwe13} on page \pageref{qwe13} it was not a good idea to start from the wellformedness of formulas as to prove the normalization theorem we need just the concepts of \femph{canonical} 
		and \femph{non-canonical} and the \femph{tree-like} structure of expressions to define the reducibility relation ricursively.
		
		In the whole article, I think, nothing else was used.
		\newpage
\section{Properties of the RI}
	\begin{lem}\label{lem:psi}
	If $\Psi(A)$ holds the followings are true:
	\begin{enumerate}
		\item If $a \in \mathcal{F}$ then $\psi(A,c_{(1)_\mathcal{F}},a)$ is derivable.
		\item If $\ps{A}{a}$ and \(a = b\) we have also  $\ps{A}{b}$
		\item If  $\ps{A}{a}$ then $a$ is normalizzable
		\item If $A=B$ then $\Psi(B)$
		\item If $A=B$ and $\Psi(B)$ then $\ps{A}{\cdot} \exteq \ps{B}{\cdot}$
		\item If $A$ is normalizzable
		\item If $A=B$ and $a=b$ then $\ps{A}{a}$ implies $\ps{B}{b}$
	\end{enumerate}
	\end{lem}
	\begin{lem}
	The lemma above is still true if we replace all $\Psi$ with $\Phi$ and all $\psi$ with $\phi$.
	Moreover if $\Psi(A)$ holds then also $\Phi(A)$ holds and we have $\psi(A) \exteq \phi(A)$
	\end{lem}
	The proofs of these two lemmas will be given by induction on the length of the derivation of $\Psi(A)$.
	
	\begin{proof}[Proof \ref{lem:psi}]
	\end{proof}
	
	
	
	
	
	
	
